# deque - double ended queue
- 임의 위치 원소 접근 : O(1)
- 맨 뒤 원소 추가 제거 : O(1)
- 벡터와 달리 맨 앞에 원소를 추가/제거하는 작업 까지도 O(1)
- 임의 위치 원소 제거/추가는 벡터와 마찬가지로 O(n)으로 수행한다.
  - 속도는 벡터보다 더빠르다.

![image](https://user-images.githubusercontent.com/69780812/142432294-d08895ff-5122-4139-bfb3-258cfbe8ce7b.png)
- deuqe은 vector보다 모든 면에서 우위에 있을까?
- 벡터와 달리 deque은 원소들이 실제로 메모리 상에서 연속적으로 존재하지 않는다.
  - 원소들이 어디에 저장되어 있는지에 대한 정보를 보관하기 위해 추가적인 메모리가 더 필요로하게 된다.
  - 64bit libc++ 라이브러리의 경우 1개원소를 보관하는 deuqe은 그 원소 크기에 비해 8배 더 많은 메모리를 필요로한다고한다.
- 실행 속도를 위해 메모리를 많이 희생하는 컨테이너라고 보면된다.
- 위 그림을 보면 원소들이 연속적으로 존재하지 않고, 일정 크기로 잘려서 각각의 블록 속에 존재한다.
  - 이 블록들이 메모리상 어느 곳에 위치해있는지 저장하기 위해 각각의 블록들의 주소를 저장하는 벡터가 필요하다.
- 벡터와 조금 다르게 새로 할당 시 앞쪽 및 뒤쪽 모두에 공간을 남겨 놓게 된다.
  - 벡터의 경우 뒤쪽에만 공간이 남았다.
  - 이를 통해 O(1)의 속도로 insert, erase를 수행할 수 있는 것이다.

![image](https://user-images.githubusercontent.com/69780812/142433118-20eb90a7-4c64-410c-9568-7e5e5a9f217b.png)
- 위 그림 상황에서 push_back(10)을 했다고 해보자.

![image](https://user-images.githubusercontent.com/69780812/142433223-5564bbda-7521-47b1-98e0-0d87dcbfd402.png)
- 단순히 새로운 블록을 만들어 추가되는 원소를 넣어준다.
- 기존 원소들을 복사할 필요가 전혀없다.

![image](https://user-images.githubusercontent.com/69780812/142433321-74687950-0b27-4f51-88d8-e9204ef4a62d.png)
- 다음은 벡터의 경우이다.
- 기존 할당한 메모리가 꽉차면 모든 원소들을 새로운 공간에 복사하게된다.
  - 따라서 평균적으로 deque이 vector보다 더 빠르게 동작하는 것이다.
- deque의 경우에도 블록 주소를 보관하는 벡터가 꽉 차게 되면 새로운 공간에 모두 복사해야되긴한다.
  - 하지만 주소 개수는 전체 원소개수보다적고, 대체로 벡터에 저장되는 객체들의 크기가 주소값의 크기보다 크므로 복사 속도가 훨씬 빠르다.

```cpp
#include <deque>

int main()
{
    std::deque<int> dq;
    dq.push_back(10);
    dq.push_front(30);

    dq.pop_front();
}
```
- push_back/push_front로 맨 앞과 뒤 원소를 추가할 수 있다.
- pop_front 함수를 통해 맨 앞의 원소를 제거할 수 있다.
- 반복자 역시 RandomAccessIterator 타입이고 벡터와 정확히 동일한 방식으로 동작한다.

# 어떤 컨테이너를 사용할 것인가 ?
- 일반적 상황 : 그냥 벡터를 사용한다.
- 만약 맨 끝이 아닌 중간에 원소들을 추가하거나 제거하는 일을 많이 하고, 원소들을 순차적으로만 접근 : 리스트를 사용한다.
- 맨 처음과 끝 모두에 원소들을 추가하는 작업을 많이하면 덱을 사용한다.